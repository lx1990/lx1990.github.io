<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>A little plan</title>
      <link href="/2019/08/25/A-little-plan/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;再次打开博客，发现已有1年的时间没有进行更新了，这不是一个好的现象。。。</p><p>&emsp;&emsp;It’s been a long time since I wrote the last article, this isn’t a good phenomenon.</p><p>&emsp;&emsp;所以从现在开始，我会尽力持续地更新我的博客，然后重点是使用英文（提升我的渣渣英语。。。）</p><p>&emsp;&emsp;So from now on I will try my best to keep updating my blog continuously, and the important thing is that I will use Chinese and English together(to improve my bad English)</p><a id="more"></a><p>—————-<strong>华丽的分割线</strong>—————-</p><p><strong>若未标明转载，本博客内容均为原创。</strong></p><p><strong>版权归作者所有，转载请注明出处。</strong></p><p><strong>若有帮助(批评指正)，还请留言，您的建议是我不断前进的动力</strong></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gitlab+gitlab-runner实现自动打包docker镜像</title>
      <link href="/2018/07/31/gitlab+gitlab-runner%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85docker%E9%95%9C%E5%83%8F/"/>
      <content type="html"><![CDATA[<p><a href="https://docs.gitlab.com/ee/README.html" target="_blank" rel="noopener">gitlab官网</a></p><h3 id="获取gitlab的docker镜像"><a href="#获取gitlab的docker镜像" class="headerlink" title="获取gitlab的docker镜像"></a>获取gitlab的docker镜像</h3><p>&emsp;&emsp;注意安装的是ce版还是ee版，我们这里使用docker(ce汉化版)进行安装。<br><a id="more"></a></p><ul><li><p>官方版</p><blockquote><p>docker pull gitlab/gitlab-ce</p></blockquote></li><li><p><a href="https://github.com/beginor/docker-gitlab-ce" target="_blank" rel="noopener">汉化版</a></p><blockquote><p>docker pull beginor/gitlab-ce:11.0.4-ce.0</p></blockquote></li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>&emsp;&emsp;先建三个文件夹，存放gitlab的配置，数据，日志</p><blockquote></blockquote><pre><code>mkdir -p /home/gitlab/configmkdir -p /home/gitlab/logsmkdir -p /home/gitlab/data</code></pre><ul><li>docker启动命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach \</span><br><span class="line">    --hostname 192.168.0.15 \</span><br><span class="line">    --publish 8443:443 --publish 880:880 --publish 822:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    --volume /home/gitlab/config:/etc/gitlab \</span><br><span class="line">    --volume /home/gitlab/logs:/var/log/gitlab \</span><br><span class="line">    --volume /home/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    beginor/gitlab-ce:11.0.1-ce.0</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这里修改了gitlab的内部服务端口，否则在创建新账号后发送的邮件中的修改密码的地址端口不正确，无法访问（可能还有其他地方会受影响），如何修改内部的端口请见下方。</p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>&emsp;&emsp;每次修改完配置后记得docker restart gitlab</p><blockquote><p>vim /home/gitlab/config/gitlab.rb</p></blockquote><ul><li><p>修改端口</p><blockquote></blockquote><p>  external_url ‘<a href="http://192.168.0.15:880&#39;" target="_blank" rel="noopener">http://192.168.0.15:880&#39;</a><br>  nginx[‘listen_port’] = 880</p></li><li><p>设置邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">### Email Settings</span><br><span class="line"> gitlab_rails[&apos;gitlab_email_enabled&apos;] = true</span><br><span class="line"> gitlab_rails[&apos;gitlab_email_from&apos;] = &apos;lx1990@xxxx.xxx&apos;</span><br><span class="line"> gitlab_rails[&apos;gitlab_email_display_name&apos;] = &apos;lx1990&apos;</span><br><span class="line"> gitlab_rails[&apos;gitlab_email_reply_to&apos;] = &apos;lx1990@xxxx.xxx&apos;</span><br><span class="line"> gitlab_rails[&apos;gitlab_email_subject_suffix&apos;] = &apos;&apos;</span><br><span class="line"></span><br><span class="line"> gitlab_rails[&apos;smtp_enable&apos;] = true</span><br><span class="line"> gitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.ym.163.com&quot;</span><br><span class="line"> gitlab_rails[&apos;smtp_port&apos;] = 25</span><br><span class="line"> gitlab_rails[&apos;smtp_user_name&apos;] = &quot;lx1990@xxxx.xxx&quot;</span><br><span class="line"> gitlab_rails[&apos;smtp_password&apos;] = &quot;xxxxxx&quot;</span><br><span class="line"> gitlab_rails[&apos;smtp_domain&apos;] = &quot;xxx.xxx&quot;</span><br><span class="line"> gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;</span><br><span class="line"> gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true</span><br><span class="line"> gitlab_rails[&apos;smtp_tls&apos;] = false</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这里使用的是网易的企业邮箱，其他邮箱具体设置方法请看文档</p><p><a href="https://docs.gitlab.com/omnibus/settings/smtp.html#doc-nav" target="_blank" rel="noopener">其他邮箱设置</a></p><ul><li><p>登录地址</p><blockquote><p>192.168.0.15:880</p></blockquote></li><li><p>登录默认密码</p><blockquote><p>5iveL!fe</p></blockquote></li></ul><p>&emsp;&emsp;第一次登陆会让你直接修改密码，用户名为<code>root</code></p><h3 id="安装运行gitlab-runner"><a href="#安装运行gitlab-runner" class="headerlink" title="安装运行gitlab-runner"></a>安装运行gitlab-runner</h3><ul><li><p>安装</p><blockquote><p>docker pull gitlab/gitlab-runner</p></blockquote></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">    -v /home/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">    -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">    gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></li><li><p>注册</p><blockquote><p>docker exec -it gitlab-runner gitlab-ci-multi-runner register</p></blockquote></li></ul><p>1.输入 GitLab 实例 URL:</p><blockquote></blockquote><pre><code>Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )http://192.168.0.15:880</code></pre><p>2.输入获取到的用于注册 Runner 的 token:</p><blockquote></blockquote><pre><code>Please enter the gitlab-ci token for this runnerxxx</code></pre><ul><li>Shared Runners(一个runner可以负责多个项目)</li></ul><p><img src="/images/share-runner.png" alt="share token"></p><ul><li>Specific Runners（一个runner只能负责对应的项目）</li></ul><p><img src="/images/spec-runner.png" alt="spec token"></p><p>3.输入该 Runner 的描述，稍后也可通过 GitLab’s UI 修改:</p><blockquote></blockquote><pre><code>Please enter the gitlab-ci description for this runner[hostame] my-runner</code></pre><p>4.给该 Runner 指派 tags, 稍后也可以在 GitLab’s UI 修改:</p><blockquote></blockquote><pre><code>Please enter the gitlab-ci tags for this runner (comma separated):my-tag,another-tag</code></pre><p>5.Enter the Runner executor:</p><blockquote></blockquote><pre><code>Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:docker</code></pre><p>6.如果你选择 Docker 作为你的 executor，注册程序会让你设置一个默认的镜像， 作用于 .gitlab-ci.yml 中未指定镜像的项目：</p><blockquote></blockquote><pre><code>Please enter the Docker image (eg. ruby:2.1):docker:stable</code></pre><p>7.修改gitlab-runner的注册信息</p><blockquote><p>vim /home/gitlab-runner/config/config.toml</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">concurrent = 1</span><br><span class="line">check_interval = 0</span><br><span class="line"></span><br><span class="line">[[runners]]</span><br><span class="line">  name = &quot;cloud&quot;</span><br><span class="line">  url = &quot;http://192.168.0.15:880/&quot;</span><br><span class="line">  token = &quot;83ad8c9b6d00417e05e5715d686dd6&quot;</span><br><span class="line">  executor = &quot;docker&quot;</span><br><span class="line">  [runners.docker]</span><br><span class="line">    tls_verify = false</span><br><span class="line">    image = &quot;docker:stable&quot;</span><br><span class="line">    privileged = false</span><br><span class="line">    disable_cache = false</span><br><span class="line">    volumes = [&quot;/var/run/docker.sock:/var/run/docker.sock&quot;, &quot;/cache&quot;]</span><br><span class="line">    cache_dir = &quot;cache&quot;</span><br><span class="line">    shm_size = 0</span><br><span class="line">  [runners.cache]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面，我们需要当我们给git打标签的时候（触发条件，可以设成别的），自动打包docker镜像并推送到镜像仓库中。</p><h3 id="gitlab-ci配置"><a href="#gitlab-ci配置" class="headerlink" title="gitlab-ci配置"></a>gitlab-ci配置</h3><ul><li>在项目中增加一个<code>.gitlab-ci.yml</code>文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">image: docker:stable</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  - docker:dind</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">  - docker login -u xxxx -p xxxx 192.168.0.15:80</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">  stage: build</span><br><span class="line">  script:</span><br><span class="line">    - pwd</span><br><span class="line">    - mv ./Dockerfile ../</span><br><span class="line">    - cd ../</span><br><span class="line">    - docker build -t 192.168.0.15:80/xxx/xxx:$CI_COMMIT_REF_NAME .</span><br><span class="line">    - docker images</span><br><span class="line">    - docker push 192.168.0.15:80/xxx/xxx:$CI_COMMIT_REF_NAME</span><br><span class="line">  only:</span><br><span class="line">    - tags</span><br><span class="line">  tags:</span><br><span class="line">    - cloud</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;至此，我们就可以实现打了tag自动生成docker镜像并推送到镜像仓库，结合之前的docker engine api的调用来方便地部署镜像</p><p>—————-<strong>华丽的分割线</strong>—————-</p><p><strong>若未标明转载，本博客内容均为原创。</strong></p><p><strong>版权归作者所有，转载请注明出处。</strong></p><p><strong>若有帮助(批评指正)，还请留言，您的建议是我不断前进的动力</strong></p>]]></content>
      
      <categories>
          
          <category> 自动化部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> gitlab-ci </tag>
            
            <tag> gitlab-runner </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker engine API</title>
      <link href="/2018/07/26/Docker%20engine%20API/"/>
      <content type="html"><![CDATA[<p><a href="https://docs.docker.com/engine/api/v1.35/" target="_blank" rel="noopener">Docker engine API官方文档</a></p><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>&emsp;&emsp;每次版本升级，都需要手动打镜像，推送仓库，拉取镜像，启动docker。。。需要敲很多的命令，比较繁琐。于是，就开始研究docker engine api，以便之后能够使用接口来替代手敲命令，同时也可升级为可视化的界面，方便部署。</p><h3 id="docker版本"><a href="#docker版本" class="headerlink" title="docker版本"></a>docker版本</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Version:       17.12.0-ce</span><br><span class="line"> API version:   1.35</span><br><span class="line"> Go version:    go1.9.2</span><br><span class="line"> Git commit:    c97c6d6</span><br><span class="line"> Built: Wed Dec 27 20:10:14 2017</span><br><span class="line"> OS/Arch:       linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:      17.12.0-ce</span><br><span class="line">  API version:  1.35 (minimum version 1.12)</span><br><span class="line">  Go version:   go1.9.2</span><br><span class="line">  Git commit:   c97c6d6</span><br><span class="line">  Built:        Wed Dec 27 20:12:46 2017</span><br><span class="line">  OS/Arch:      linux/amd64</span><br><span class="line">  Experimental: false</span><br></pre></td></tr></table></figure><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><ul><li><p>打开docker的配置</p><blockquote><p>vim /usr/lib/systemd/system/docker.service</p></blockquote></li><li><p>连接镜像仓库&amp;&amp;配置docker源地址</p><blockquote></blockquote><p>  添加如下参数：<br>  ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock –insecure-registry 192.168.0.15:80 –insecure-registry xxx.xxx.xxx.xxx –registry-mirror <a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a> –registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> –registry-mirror <a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p></li><li><p>重启docker</p><blockquote></blockquote><p>  systemctl daemon-reload<br>  service docker restart</p></li></ul><h3 id="使用api"><a href="#使用api" class="headerlink" title="使用api"></a>使用api</h3><ul><li><p>你的访问域名就是添加了参数的主机地址</p></li><li><p>需要注意一点：认证问题</p></li></ul><blockquote><p>/auth接口，认证的时候”IdentityToken”返回值为空(我尝试过，但是没有成功返回token)</p></blockquote><blockquote><p>在create image的时候(从仓库拉取镜像到本地)，在header中加入X-Registry-Auth参数,下面会详细说明</p></blockquote><h3 id="具体接口说明"><a href="#具体接口说明" class="headerlink" title="具体接口说明"></a>具体接口说明</h3><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><blockquote><p>method：POST<br>/auth</p></blockquote><p>请求参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;: &quot;hannibal&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;xxxx&quot;,</span><br><span class="line">    &quot;serveraddress&quot;: &quot;https://index.docker.io/v1/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h4><ul><li><p>List images（列出本地所有镜像）</p><blockquote><p>method：GET<br>/images/json?all=true</p></blockquote></li><li><p>Create an image（从镜像仓库拉取镜像）</p><blockquote><p>method：POST<br>/images/create?fromImage=镜像名字</p></blockquote></li></ul><p>&emsp;&emsp;Header：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X-Registry-Auth:下方json对象整体的base64转码</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;username&quot;: &quot;hannibal&quot;,</span><br><span class="line">        &quot;password&quot;: &quot;xxxx&quot;,</span><br><span class="line">        &quot;serveraddress&quot;: &quot;https://index.docker.io/v1/&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>Remove an image（删除镜像）</p><blockquote><p>method：DELETE<br>/images/{Image name or ID}</p></blockquote></li><li><p>Tag an image（给镜像打tag）</p><blockquote><p>method：POST<br>/images/{Image name or ID}/tag</p></blockquote></li><li><p>Push an image（推送镜像至仓库）</p><blockquote><p>method：POST<br>/images/{Image name or ID}/push</p></blockquote></li></ul><h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h4><ul><li><p>List containers（列出所有容器）</p><blockquote><p>method：GET<br>/containers/json?all=true</p></blockquote></li><li><p>Create a container（创建容器）</p><blockquote><p>method：POST<br>/containers/create?name=给容器起的名字</p></blockquote></li></ul><p>请求参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Env&quot;:[</span><br><span class="line">        &quot;CLOUD_PORT=4000&quot;,</span><br><span class="line">        &quot;CLOUD_APP_NAME=cloud&quot;</span><br><span class="line">    ],</span><br><span class="line">    # 启动命令必须按照这样的格式写，不然会报错</span><br><span class="line">    &quot;Cmd&quot;: [&quot;pm2&quot;, &quot;start&quot; ,&quot;app.js&quot; ,&quot;-i&quot;, &quot;2&quot;],</span><br><span class="line">    &quot;Image&quot;: &quot;镜像名称&quot;,</span><br><span class="line">    &quot;Tag&quot;: &quot;latest&quot;,</span><br><span class="line">    # Volumes+HostConfig中的Binds等同于：-v</span><br><span class="line">    &quot;Volumes&quot;: &#123;</span><br><span class="line">        &quot;/usr/src/app/config/local.js&quot;: &#123;&#125;,</span><br><span class="line">        &quot;/usr/src/logs&quot;: &#123;&#125;,</span><br><span class="line">        &quot;/etc/localtime&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;HostConfig&quot;: &#123;</span><br><span class="line">        &quot;Binds&quot;: [</span><br><span class="line">            &quot;/home/cloud_new/local.js:/usr/src/app/config/local.js&quot;,</span><br><span class="line">            &quot;/home/cloud_new/logs/:/usr/src/logs&quot;,</span><br><span class="line">            &quot;/etc/localtime:/etc/localtime:ro&quot;</span><br><span class="line">        ],</span><br><span class="line">        # 等同于：–restart=unless-stopped</span><br><span class="line">        &quot;RestartPolicy&quot;:&#123;</span><br><span class="line">            &quot;Name&quot;: &quot;unless-stopped&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        # 等同于：–net=host</span><br><span class="line">        &quot;NetworkMode&quot;:&quot;host&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>Remove a container（删除容器）</p><blockquote><p>method：DELETE<br>/containers/{ID or name of the container}</p></blockquote></li><li><p>Start a container（启动容器）</p><blockquote><p>method：POST<br>/containers/{ID or name of the container}/start</p></blockquote></li><li><p>Stop a container（停止容器）</p><blockquote><p>method：POST<br>/containers/{ID or name of the container}/stop</p></blockquote></li><li><p>Restart a container（重启容器）</p><blockquote><p>method：POST<br>/containers/{ID or name of the container}/restart</p></blockquote></li><li><p>Kill a container（停止容器）</p><blockquote><p>method：POST<br>/containers/{ID or name of the container}/kill</p></blockquote></li></ul><p>—————-<strong>华丽的分割线</strong>—————-</p><p><strong>若未标明转载，本博客内容均为原创。</strong></p><p><strong>版权归作者所有，转载请注明出处。</strong></p><p><strong>若有帮助(批评指正)，还请留言，您的建议是我不断前进的动力</strong></p>]]></content>
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>confd+nginx+etcd实现无感知升级</title>
      <link href="/2018/07/26/confd+nginx+etcd%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%84%9F%E7%9F%A5%E5%8D%87%E7%BA%A7/"/>
      <content type="html"><![CDATA[<p><a href="http://www.confd.io/" target="_blank" rel="noopener">confd官网</a></p><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>&emsp;&emsp;基于我们现在自己服务的体量，发现使用<code>confd+nginx+etcd+docker</code>能够满足我们实现无感知升级的需求，且比较轻量。遂，组长让我研究一下<code>confd</code>。<code>nginx</code>、<code>ectd</code>和<code>docker</code>这里不做过多的介绍，只关注<code>confd</code>。</p><h3 id="无感知原理"><a href="#无感知原理" class="headerlink" title="无感知原理"></a>无感知原理</h3><a id="more"></a><p>&emsp;&emsp;假设我们有一个服务起了两个<code>docker</code>镜像，那么我们把这两个镜像的地址都放在<code>etcd</code>中，并启动在<code>confd</code>进行监测。<br>&emsp;&emsp;当我们需要对服务进行升级时，我们可以先在<code>etcd</code>中删除一个<code>docker</code>的地址，这样<code>confd</code>会检测到配置有变动，重新生成新的<code>nginx</code>配置文件并且重启<code>nginx</code>。<br>&emsp;&emsp;因为<code>nginx</code>的重启时间相当短暂，几乎在瞬间完成，所以此时<code>nginx</code>指向不到已经删除掉的<code>docker</code>地址，我们可以升级完服务，启动新的<code>docker</code>，再将新的<code>docker</code>服务的地址放回<code>etcd</code>中，剩下的老的<code>docker</code>服务也以此类推，从而做到无感知升级。</p><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><blockquote><p>centos7</p></blockquote><h3 id="安装confd"><a href="#安装confd" class="headerlink" title="安装confd"></a>安装confd</h3><ul><li>下载+安装<blockquote></blockquote>  wget <a href="https://github.com/kelseyhightower/confd/releases/download/v0.16.0/confd-0.16.0-linux-amd64" target="_blank" rel="noopener">https://github.com/kelseyhightower/confd/releases/download/v0.16.0/confd-0.16.0-linux-amd64</a><br>  mkdir -p /opt/confd/bin<br>  mv confd-0.16.0-linux-amd64 /opt/confd/bin/confd<br>  chmod +x /opt/confd/bin/confd<br>  export PATH=”$PATH:/opt/confd/bin”</li></ul><p>&emsp;&emsp;使用前需要创建相应的配置目录</p><h3 id="配置confd"><a href="#配置confd" class="headerlink" title="配置confd"></a>配置confd</h3><ul><li><p>创建配置目录</p><blockquote><p>mkdir -p /etc/confd/{conf.d,templates}</p></blockquote></li><li><p>在<code>/etc/confd/conf.d</code>下创建配置文件：</p><blockquote><p>vim /etc/confd/conf.d/cloud.toml</p></blockquote></li></ul><p>&emsp;&emsp;这个里面是confd生成的nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># etcd中keys的前缀</span><br><span class="line">prefix = &quot;/cloud&quot;</span><br><span class="line"># src指/etc/confd/templates中的模板文件的名字</span><br><span class="line">src = &quot;cloud.conf.tmpl&quot;</span><br><span class="line"># dest指nginx配置文件生成目录</span><br><span class="line">dest = &quot;/etc/nginx/conf.d/cloud.conf&quot;</span><br><span class="line"># keys指的是etcd中的keys</span><br><span class="line">keys = [</span><br><span class="line">    &quot;/subdomain&quot;,</span><br><span class="line">    &quot;/upstream&quot;</span><br><span class="line">]</span><br><span class="line">reload_cmd = &quot;nginx -s reload&quot;</span><br><span class="line">#reload_cmd = &quot;service nginx reload&quot;</span><br></pre></td></tr></table></figure><ul><li>在<code>/etc/confd/templates</code>下创建模板文件：<blockquote><p>vim /etc/confd/templates/cloud.conf.tmpl</p></blockquote></li></ul><p>&emsp;&emsp;这个里面是nginx的upstream的模板，被<code>/etc/confd/conf.d/cloud.toml</code>读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># upstream指从etcd某个键中读取出来的数据</span><br><span class="line">upstream &#123;&#123;getv &quot;/subdomain&quot;&#125;&#125; &#123;</span><br><span class="line">    &#123;&#123;range getvs &quot;/upstream/*&quot;&#125;&#125;</span><br><span class="line">        server &#123;&#123;.&#125;&#125;;</span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      443 ;</span><br><span class="line">        server_name  jswym.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass        http://&#123;&#123;getv &quot;/subdomain&quot;&#125;&#125;;</span><br><span class="line">            proxy_redirect    off;</span><br><span class="line">            proxy_set_header  Host             $host;</span><br><span class="line">            proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改nginx中的配置<blockquote><p> vim /etc/nginx/nginx.conf </p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_host&quot; &apos;</span><br><span class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;</span><br><span class="line">                    &apos;&quot;$upstream_addr&quot; &quot;$upstream_cache_status&quot; &quot;$upstream_status&quot; &quot;$upstream_response_time&quot;&apos;</span><br><span class="line">                    &apos;&quot;$Cookie_CookKey&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/nginx_access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重点是include这一行</span><br></pre></td></tr></table></figure><h3 id="执行生成配置文件"><a href="#执行生成配置文件" class="headerlink" title="执行生成配置文件"></a>执行生成配置文件</h3><blockquote></blockquote><pre><code>confd -onetime -backend etcd -node http://127.0.0.1:2379    只一次confd -interval=60 -backend etcd -node http://127.0.0.1:2379 &amp;   按时间轮询</code></pre><p>&emsp;&emsp;上述俩http地址为etcd的地址，自行替换即可</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><blockquote><p>etcdctl set /cloud/upstream/192.168.0.98_1337 192.168.0.98:1337</p></blockquote><p>&emsp;&emsp;接下来，当你在对etcd进行操作的时候，如上，confd会进行轮询，发现有所改动，自动生成nginx的配置文件，并重启nginx</p><h2 id="docker化confd"><a href="#docker化confd" class="headerlink" title="docker化confd"></a>docker化confd</h2><ul><li><p>docker启动命令</p><blockquote></blockquote><p>  docker run –name confd –restart=always -v /etc/confd/conf.d/:/etc/confd/conf.d/ -v /etc/confd/templates/:/etc/confd/templates/ -v /etc/nginx/conf.d/:/etc/nginx/conf.d/ –net=host -d confd  sh -c “/opt/confd/bin/run.sh  ‘10’ ‘<a href="http://192.168.0.71:2379&#39;" target="_blank" rel="noopener">http://192.168.0.71:2379&#39;</a> “<br>  10 表示多少秒轮询一次；后面的地址是etcd的地址</p></li><li><p>Dockerfile</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line">MAINTAINER lx1990</span><br><span class="line">WORKDIR /opt/confd/bin</span><br><span class="line">COPY ./confd /opt/confd/bin/confd</span><br><span class="line">COPY ./run.sh /opt/confd/bin/run.sh</span><br><span class="line">RUN chmod +x /opt/confd/bin/run.sh</span><br><span class="line">RUN mkdir -p /etc/confd/conf.d</span><br><span class="line">RUN mkdir -p /etc/confd/templates</span><br><span class="line">RUN mkdir -p /etc/nginx/conf.d</span><br></pre></td></tr></table></figure><ul><li>run.sh</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cd /opt/confd/bin</span><br><span class="line">./confd -interval=$1 -backend etcd -node $2 &amp;</span><br><span class="line">nginx -g &apos;daemon off;&apos;</span><br></pre></td></tr></table></figure><p>—————-<strong>华丽的分割线</strong>—————-</p><p><strong>若未标明转载，本博客内容均为原创。</strong></p><p><strong>版权归作者所有，转载请注明出处。</strong></p><p><strong>若有帮助(批评指正)，还请留言，您的建议是我不断前进的动力</strong></p>]]></content>
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> confd </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github搭建博客</title>
      <link href="/2018/07/26/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p><p>&emsp;&emsp;前文说到此博客是基于hexo框架+github搭建起来的，下面来进行详细说明搭建过程。</p><h3 id="在github注册博客地址"><a href="#在github注册博客地址" class="headerlink" title="在github注册博客地址"></a>在github注册博客地址</h3><blockquote><p> github上新建一个仓库，命名为XXXX.github.io，xxxx为你的用户名<br><a id="more"></a></p></blockquote><h3 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h3><ul><li><strong>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs</a></strong></li><li><strong>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></strong></li><li><p><strong>安装hexo-cli</strong></p><blockquote><p>npm install -g hexo-cli</p></blockquote></li><li><p><strong>建站</strong></p><blockquote><p>hexo init &lt;folder><br>cd &lt;folder><br>npm install</p></blockquote></li></ul><h3 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h3><ul><li><strong>启动hexo</strong><blockquote><p>hexo server </p></blockquote></li></ul><p>&emsp;&emsp;此时，访问localhost:4000，已经可以看到博客了</p><ul><li><strong>新增一篇文章</strong><blockquote><p>hexo new &lt;title></p></blockquote></li></ul><p>&emsp;&emsp;此时，在项目内的<code>source/_posts</code>目录下会出现一个名为title的md文件，进入编辑即可</p><ul><li><strong>生成静态文件</strong><blockquote><p>hexo generate </p></blockquote></li></ul><p>&emsp;&emsp;接下来启动服务，可以看到新增的文章已经更新上去了</p><h3 id="部署-git版本"><a href="#部署-git版本" class="headerlink" title="部署(git版本)"></a>部署(git版本)</h3><p>&emsp;&emsp;Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><ul><li><strong>安装部署模块</strong><blockquote><p>npm install hexo-deployer-git –save</p></blockquote></li><li><p><strong>在<code>_config.yml</code>中修改参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p><strong>部署</strong></p><blockquote><p>hexo deploy </p></blockquote></li></ul><p>&emsp;&emsp;随后，访问你自己的地址xxx.github.io</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><strong>init</strong><blockquote><p>hexo init [folder]</p></blockquote></li></ul><p>&emsp;&emsp;新建一个网站。如果没有设置<code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p><ul><li><strong>new</strong> <blockquote><p>hexo new [layout] &lt;title></p></blockquote></li></ul><p>&emsp;&emsp;新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><ul><li><p><strong>generate</strong></p><blockquote><p>hexo generate 可简写为：hexo g</p></blockquote></li><li><p><strong>server</strong></p><blockquote><p>hexo server 可简写为：hexo s</p></blockquote></li><li><p><strong>clean</strong> </p><blockquote><p>hexo clean</p></blockquote></li></ul><p>&emsp;&emsp;清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><ul><li><p><strong>deploy</strong></p><blockquote><p>hexo deploy 可简写为：hexo d</p></blockquote></li><li><p><strong>文件生成后立即部署网站</strong></p><blockquote><p>hexo g -d 或 hexo d -g</p></blockquote></li></ul><p>—————-<strong>华丽的分割线</strong>—————-</p><p><strong>若未标明转载，本博客内容均为原创。</strong></p><p><strong>版权归作者所有，转载请注明出处。</strong></p><p><strong>若有帮助(批评指正)，还请留言，您的建议是我不断前进的动力</strong></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不知所云</title>
      <link href="/2018/07/24/%E4%B8%8D%E7%9F%A5%E6%89%80%E4%BA%91/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;去年我也曾在VPS上部署过一个博客，计划把一些心得总结梳理在上面。</p><p>&emsp;&emsp;但是总因一些这儿或者那的事情（归根结底还是懒惰）搁置，最终结果就是一篇都没写。</p><p>&emsp;&emsp;最近正好研究的东西比较多，想记录下来（一直笔记都放在有道云），正巧有朋友问我之前弄的博客相关信息，遂决定继续启动博客项目，并将其部署在github上。<br><a id="more"></a><br>&emsp;&emsp;为什么要部署在github上，而不是部署在自己的vps上，原因主要有两点：</p><p>&emsp;&emsp;1、github相对自己的vps来说更加稳定（大品牌，信得过）</p><p>&emsp;&emsp;2、vps的硬盘比较小（屌丝乞丐版），当时的定位就是梯子和折腾，环境相对不够稳定，不适合部署服务。</p><p>&emsp;&emsp;本博客使用hexo搭建，具体请移步<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>，这里不再多做介绍，后续会详细说明搭建过程。</p><p>&emsp;&emsp;博客的主题为Nayo，具体请移步<a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank" rel="noopener">Nayo</a>。</p><p>&emsp;&emsp;行百里者半九十，希望我能够坚持下去记录我的技术成长（立个长期的flag）。</p><p>—————-<strong>华丽的分割线</strong>—————-</p><p><strong>若未标明转载，本博客内容均为原创。</strong></p><p><strong>版权归作者所有，转载请注明出处。</strong></p><p><strong>若有帮助(批评指正)，还请留言，您的建议是我不断前进的动力</strong></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello world</title>
      <link href="/2018/07/17/hello%20world/"/>
      <content type="html"><![CDATA[<p>一楼hello world</p>]]></content>
      
      
    </entry>
    
  
  
</search>
